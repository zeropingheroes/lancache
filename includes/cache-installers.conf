# Use the cache named "installers"
proxy_cache installers;

# Pass the entire request URI through to the upstream server
proxy_pass http://$host$request_uri;

# Don't modify Refresh: and Location: headers sent from upstreams
proxy_redirect off; 

# Send Host: header from client's request to upstreams
proxy_set_header Host $host;

# Upstream request headers
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

# Useful headers for debugging / stats
add_header X-Upstream-Status $upstream_status;
add_header X-Upstream-Response-Time $upstream_response_time;
add_header X-Upstream-Cache-Status $upstream_cache_status;

# Continue downloading a requested file/slice from upstream, even if a client cancels
proxy_ignore_client_abort on;

# Only download the same file once, even if multiple clients 
# request it before Nginx has finished downloading the file.
# Timeout set to 1 hour to give Nginx plenty of time to get the file
proxy_cache_lock on;
proxy_cache_lock_timeout 1h;

# Allow the use of stale entries if there is an upstream error
proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;

# Keep files for 7 days when upstream server gives HTTP 200 (OK) or HTTP 206 (Partial Content)
proxy_cache_valid 200 206 7d;

# Disallow caching of HTTP 301 (Moved Permanently) or HTTP 302 (Found) as our
# cache key does not include query parameters (e.g. ?a=b), therefore may not be valid for all users
proxy_cache_valid 301 302 0;

# Enable revalidation of expired cache items using conditional requests, to save re-downloading files
# that have not been modified
proxy_cache_revalidate on;

# Don't cache requests which have the query parameter ?nocache=1
proxy_cache_bypass $arg_nocache;

